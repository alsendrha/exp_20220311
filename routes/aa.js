-- 시퀀스 생성 SEQ_ITEM1_ITEMNO

CREATE SEQUENCE SEQ_ITEM1_ITEMNO
    START WITH 1001 INCREMENT BY 1 NOMAXVALUE;
-- 시작숫자 1001, 1, NOMAXVALUE

-- ITEM1 테이블에 시퀀스를 이용해서 5개 추가
INSERT INTO ITEM1(ITEMNO, ITEMNAME, ITEMPRICE, ITEMQTY, ITEMDATE) VALUES(SEQ_ITEM1_ITEMNO.NEXTVAL, 'EEE', 6000, 10, CURRENT_DATE);

-- ITEM1에 재고 수량이 100미만은 100으로 변경
UPDATE ITEM1 SET ITEMQTY=100 WHERE ITEMQTY <100;

-- ITEM1에 재고수량 *금액값을 TOTAL 컬럼으로 추가한 후 조회
SELECT ITEMNO, ITEMNAME, ITEMPRICE, ITEMQTY, ITEMDATE, ITEMPRICE*ITEMQTY TOTAL FROM ITEM1;

-- ITEM1에 "검색어"가 포함된것 조회 EX) 검색어 문자'1'
SELECT * FROM ITEM1 WHERE ITEMNAME LIKE '%'||'A'||'%';

-- MEMBER1에 회원 3명 추가
INSERT INTO MEMBER1(USERID, USERPW, USERNAME, USERAGE, USERDATE, USERADDR) VALUES('C', 'A', 'TTT', 20, CURRENT_DATE, 'AASD'); 

-- 회원이름 순으로 오름차순 정렬해서 조회
SELECT * FROM MEMBER1 ORDER BY USERNAME ASC; 

-- 나이가 30 이상인 사람만 조회
SELECT * FROM MEMBER1 WHERE USERAGE >= 30; 

-- 시퀀스 생성 SEQ_ORDER1_ORDNO
-- 시작숫자 10001, 1, NOMAXVALUE
CREATE SEQUENCE SEQ_ORDER1_ORDNO
    START WITH 10001 INCREMENT BY 1 NOMAXVALUE;
-- 주문 3건 수행하기(ITEM1, MEMBER1 외래키)
INSERT INTO ORDER1(ORDNO, ORDCNT, ORDDATE, ORDITEM, ORDID) VALUES(SEQ_ORDER1_ORDNO.NEXTVAL, 1200, CURRENT_DATE, 1004, 'C');

-- 주문내역을 주문일자 기준으로 내림차순 정렬 조회
SELECT * FROM ORDER1 ORDER BY ORDDATE DESC; 
-- 주문수량이 1000 이상인것만 조회
SELECT * FROM ORDER1 WHERE ORDCNT >= 1000; 

SELECT * FROM ORDER1 WHERE ORDCNT >= 1000 ORDER BY ORDDATE DESC;

SELECT * FROM ITEM1;
SELECT * FROM MEMBER1;
SELECT * FROM ORDER1;

COMMIT;
ROLLBACK;

SELECT * FROM BOARD3;
-- 검색
-- 제목에 "가" 포함된 것 검색
-- SELECT 컬럼 FROM 테이블 WHERE 컬럼 LIKE 검색어
-- ORDER BY 컬럼 ASC||DESC
SELECT NO, TITLE, WRITER, HIT, REGDATE FROM BOARD3 WHERE TITLE LIKE '%'|| '가'||'%' ORDER BY NO DESC;

-- 페이지네이션
-- (EX)DT, ROWN) 클럽명 뒤쪽에 입력하면 변경됨
-- BOARD3 => 컬럼 ROWN 추가 => 조회
SELECT 
    NO NO, TITLE TITLE, WRITER WRITER, HIT HIT, REGDATE DT 
FROM
    BOARD3;

SELECT * FROM (
SELECT 
    NO NO, TITLE TITLE, WRITER WRITER, HIT HIT, REGDATE DT, 
    ROW_NUMBER() OVER (ORDER BY NO DESC) ROWN
FROM
    BOARD3
)BOARD33 WHERE ROWN BETWEEN 1 AND 9;

CREATE OR REPLACE VIEW BOARD33 AS
SELECT 
    NO NO, TITLE TITLE, WRITER WRITER, HIT HIT, REGDATE DT, 
    ROW_NUMBER() OVER (ORDER BY NO DESC) ROWN
FROM
    BOARD3;

SELECT * FROM BOARD33;
---------------------------------------------------------------------------------
INSERT INTO BOARD3(NO, TITLE, CONTENT, WRITER, HIT, REGDATE) VALUES(SEQ_BOARD3_NO.NEXTVAL, '가가가', '나나', 'A', 1, CURRENT_DATE);

SELECT * FROM MEMBER3 WHERE ID IN('A','B','C');

SELECT * FROM MEMBER3 WHERE ID IN('A','B','C') ORDER BY ID DESC;

-- 게시판 조회수가 20이상인것을 글번호 기준 내림차순으로 조회
SELECT * FROM BOARD3 WHERE HIT >= 20 ORDER BY NO DESC;

-- 삭제하기
-- DELETE FROM 테이블명 WHERE 조건;
DELETE FROM BOARD3 WHERE NO=2;

COMMIT;
ROLLBACK;

SELECT * FROM BOARD3;
SELECT * FROM MEMBER3;

-- 기본적으로 외래키로 등록된 ID가 게시한글이 있을경우 삭제 불가
-- 회원삭제, 중요정보를 UPDATE를 함.
DELETE FROM MEMBER3 WHERE ID='B';

---------------------------------------------------------------------------------
-- 게시판에서 글번호가 1번인것의 제목을 'BBB; 조회수를 10
-- 게시판에서 조회수가 0~9 => 10
-- 조회수가 10~20 => 20
-- 조회수가 30~40 => 30
-- 나머지는 40
UPDATE BOARD3 SET TITLE='BBB', HIT=10 WHERE NO=1;

-- 글번호 1,3,5번 인 항목 수정
UPDATE BOARD3 SET TITLE='BBB', HIT=10 WHERE NO=1 OR NO=3 OR NO=5;
UPDATE BOARD3 SET TITLE='BBB', HIT=10 WHERE NO IN(1 ,3 ,5);
UPDATE BOARD3 SET HIT=
    CASE
        WHEN (HIT >=0 AND HIT <= 9)THEN 10
        WHEN (HIT >=10 AND HIT <=20)THEN 20
        WHEN (HIT >=30 AND HIT <=40)THEN 30
        ELSE 40
    END;    

COMMIT;
ROLLBACK;

SELECT * FROM BOARD3;

-- 수정하기

-- UPDATE 테이블명 SET 컬럼명 = 변경값, 컬럼명 = 변경값 WHERE 조건;
UPDATE MEMBER3 SET AGE=22, PHONE='010-9898-7069' WHERE ID= 'A';

-- 나이가 0~20까지는 나이를 200으로 아니면 300으로 변경
-- 나이가 21~40이면 나이를 300
-- 나머지는 400으로 변경
UPDATE MEMBER3 SET AGE = 
    CASE
        WHEN (AGE >=0 AND AGE <= 20) THEN 200
        WHEN (AGE >=21 AND AGE <= 40) THEN 300
        ELSE 400
    END;    

COMMIT;
ROLLBACK;

-- 제약조건이 걸린건 그와 연결된 테이블이 채워져야 사용가능


-- 전체조회
SELECT * FROM MEMBER3;

-- 추가하기
-- INSERT INTO 테이블명(컬럼명) VALUES(추가값);
INSERT INTO MEMBER3(ID, PW, AGE, PHONE, GENDER, REGDATE, REGDATE1) VALUES('D', 'A', 11, '010-000-0000', 'F', CURRENT_DATE, CURRENT_DATE); 

-- 일괄등록(들어가거나 안들어가거나)
INSERT ALL INTO MEMBER3(ID, PW, AGE, PHONE, GENDER, REGDATE, REGDATE1) VALUES('E', 'A', 11, '010-000-0000', 'F', CURRENT_DATE, CURRENT_DATE)
            INTO MEMBER3(ID, PW, AGE, PHONE, GENDER, REGDATE, REGDATE1) VALUES('F', 'A', 11, '010-000-0000', 'F', CURRENT_DATE, CURRENT_DATE)
            INTO MEMBER3(ID, PW, AGE, PHONE, GENDER, REGDATE, REGDATE1) VALUES('G', 'A', 11, '010-000-0000', 'F', CURRENT_DATE, CURRENT_DATE)
SELECT * FROM DUAL;

COMMIT; -- 적용하기 (추가, 삭제, 수정)
ROLLBACK; -- 되돌리기

-- 시퀀스 생성하기
CREATE SEQUENCE SEQ_BOARD3_NO
    START WITH 1 INCREMENT BY 1 NOMAXVALUE;

INSERT INTO BOARD3(NO, TITLE, CONTENT, WRITER, HIT, REGDATE) VALUES(SEQ_BOARD3_NO.NEXTVAL, 'A', 'A', 'A', 1, CURRENT_DATE); 

COMMIT; -- 적용하기 (추가, 삭제, 수정)
ROLLBACK; -- 되돌리기

SELECT * FROM BOARD3;

SELECT SEQ_BOARD3_NO.CURRVAL FROM DUAL; 

-- 데이터 정의어 : DDL
-- 테이블생성 및 구조, 제약조건 등을 설정
CREATE TABLE MEMBER3 (
    ID VARCHAR2(30),
    FW VARCHAR2(200),
    AGE NUMBER(3),
    PHONE VARCHAR2(15),
    GENDER VARCHAR2(1),
    REGDATE DATE,
    REGDATE1 TIMESTAMP,
    CONSTRAINT PK_MEMBER3_ID PRIMARY KEY(ID),
    CONSTRAINT CK_MEMBER3_GENDER CHECK (GENDER IN ('M','F'))
);

-- 주소컬럼추가
ALTER TABLE MEMBER3 ADD ADDR VARCHAR2(100);

-- 주소 타입의 길이 100 -> 120
ALTER TABLE MEMBER3 MODIFY ADDR VARCHAR2(120);

-- 주소 컬럼 삭제
ALTER TABLE MEMBER3 DROP COLUMN ADDR;

-- 기본키 제약조건 설정(동작안됨)
ALTER TABLE MEMBER3 ADD
    CONSTRAINT PK_MEMBER3_ID PRIMARY KEY(ID);
    
-- 성별에 not null 추가
ALTER TABLE MEMBER3 MODIFY GENDER NOT NULL;

-- 연락처에 고유값(UNIQUE) 설정(제약조건)
ALTER TABLE MEMBER3 ADD CONSTRAINT UQ_MEMBER3_PHONE UNIQUE(PHONE);

-- 제약조건 삭제
ALTER TABLE MEMBER3 DROP CONSTRAINT UQ_MEMBER3_PHONE;  


-- 게시판(BOARD3) 테이블 생성
CREATE TABLE BOARD3(
    NO NUMBER,
    TITLE VARCHAR2(20),
    CONTENT CLOB,
    WRITER VARCHAR2(30),
    HIT NUMBER,
    REGDATE DATE,
    CONSTRAINT PK_BOARD3_NO PRIMARY KEY(NO),
    CONSTRAINT FK_BOARD3_WRITER FOREIGN KEY(WRITER)REFERENCES MEMBER3
)

ALTER TABLE BOARD3 ADD CONSTRAINT PK_BOARD3_ID PRIMARY KEY(NO);
ALTER TABLE BOARD3 DROP CONSTRAINT PK_BOARD3_ID;
ALTER TABLE BOARD3 MODIFY NO not null;
ALTER TABLE BOARD3 MODIFY TITLE VARCHAR2(100);
DROP TABLE BOARD3 CASCADE CONSTRAINTS; 

-- 제약조건 기본키(PK), 외래키(FK), 체크(CK), 고유값(UQ)

-- 부서테이블(department)
-- 1. 테이블생성(제약조건x)
-- 부서번호 : NO
-- 부서명 : NAME
-- 2. 제약조건 : 기본키
-- 3. 지역컬럼 추가(AREA VARCHAR2(20))
-- 4. 지역컬럼의 체크값을 "부산", "서울", "대전"만 가능하게
-- 5. 부서명의 길이를 30으로 변경
-- 6. 부서명에 not null 추가
-- 7. 부서명에 UNIQUE 제약조건 성정 UQ_DEPT_NAME

CREATE TABLE DEPARTMENT(
    NO NUMBER,
    NAME VARCHAR2(20)
);

ALTER TABLE DEPARTMENT ADD CONSTRAINT PK_DEPARTMENT_NO PRIMARY KEY(NO);

ALTER TABLE DEPARTMENT ADD AREA VARCHAR2(20);

ALTER TABLE DEPARTMENT ADD CONSTRAINT CK_DEPARTNEMT_AREA CHECK(AREA IN('부산', '서울', '대전'));

ALTER TABLE DEPARTMENT MODIFY NAME VARCHAR2(30);

ALTER TABLE DEPARTMENT MODIFY NAME not null;

ALTER TABLE DEPARTMENT ADD CONSTRAINT UQ_DEPT_NAME UNIQUE(NAME);

-- 회사원 테이블(employee)
-- 1. (제약조건 , 기본키, 체크만)
-- 사원번호 : NO (PK)
-- 이름 : NAME
-- 부서번호 : DEPTNO(FK)
-- 상사번호 : PEMPNO
-- 직급 : POSITION VARCHAR(10), (CK -"대리", "과장", "부장", "차장")만 가능
-- 급여 : PAY NUMBER
-- 등록일 : REGDATE DATE
-- 2. 부서 테이블의 부서번호를 회사원테이블의 부서 번호와 외래키 연결

CREATE TABLE EMPLOYEE(
    NO NUMBER PRIMARY KEY,
    NAME VARCHAR2(20),
    DEPTNO NUMBER,
    PEMPNO NUMBER,
    POSITION VARCHAR(10),
    PAY NUMBER,
    REGDATE DATE,
    CONSTRAINT CK_EMPLOYEE_POSITION CHECK(POSITION IN('대리','과장','부장','차장'))
)
ALTER TABLE EMPLOYEE ADD CONSTRAINT FK_EMPLOYEE_DEPTNO FOREIGN KEY(DEPTNO)REFERENCES DEPARTMENT(NO);



-- 시스템 계정 => system / 111
-- 데이터제어어(DCL) 사용자를 추가, 권한부여, 권한삭제, 제거

-- 계정생성 (ex GUEST2XX, 암호 1234)
CREATE USER GUEST215 IDENTIFIED BY "1234";

-- 계정확인
SELECT * FROM DBA_USERS;

-- 권한부여 (접속, 리소스)
GRANT CONNECT, RESOURCE TO GUEST215;

-- 권한회수, 제거(접속, 리소스)
REVOKE CONNECT, RESOURCE FROM GUEST215;

-- 계정삭제
DROP USER GUEST215 CASCADE;

======================================================================================================

SELECT * FROM ITEM1;
SELECT * FROM MEMBER1;
SELECT * FROM ORDER1;

-- inner join(다른곳에서 안될수도 있음 oracle)
-- SELECT * FROM 테이블1, 테이블2 WHERE 테이블1.컬럼=테이블2.컬럼;

-- ansi sql(oracle, nysql, mssql...) 모든곳에서 먹힘
-- SELECT * FROM 테이블1 INNER JOIN 테이블2 ON 테이블1.컬럼=테이블2.컬럼;
SELECT * FROM ITEM1, ORDER1 WHERE ITEM1.ITEMNO=ORDER1.ORDITEM;

CREATE OR REPLACE VIEW ORDER1VIEW AS
SELECT
    ITEMORDER1.*, MEMBER1.USERNAME, MEMBER1.USERADDR 
FROM MEMBER1, (
    SELECT ITEM1.ITEMNAME, ITEM1.ITEMPRICE, ORDER1.*
    FROM
        ITEM1, ORDER1
    WHERE
        ITEM1.ITEMNO=ORDER1.ORDITEM) ITEMORDER1
WHERE MEMBER1.USERID=ITEMORDER1.ORDID; 

-- VIEW는 조회만 가능함( RODER1, MEMBER1, ITEM1)
SELECT * FROM ORDER1VIEW;

INSERT INTO ORDER1(ORDNO, ORDCNT, ORDDATE, ORDITEM, ORDID) VALUES(SEQ_ORDER1_ORDNO.NEXTVAL, 1200, CURRENT_DATE, 1004, 'C');
COMMIT;
INSERT INTO MEMBER1(USERID, USERPW, USERNAME, USERAGE, USERDATE, USERADDR) VALUES('D', 'A', 'DDD', 20, CURRENT_DATE, 'AASD'); 

-- left outer join(왼쪽 전체 + 오른쪽 일치하는 것만)
SELECT * FROM ITEM1, ORDER1 WHERE ITEM1.ITEMNO = ORDER1.ORDITEM(+);
-- ANSL SQL
SELECT * FROM ITEM1 INNER JOIN ORDER1 ON ITEM1.ITEMNO = ORDER1.ORDITEM(+);

-- SELECT * FROM 테이블1 LEFT OUTER JOIN 테이블2
-- ON ITEM1.ITEMNO = ORDER1.ORDITEM;

-- right outer join
-- SELECT * FROM TABLE1 RIGHT OUTER JOIN TABLE2 ON 조건;

SELECT * FROM ORDER1 INNER JOIN MEMBER1 ON ORDER1.ORDID(+)=MEMBER1.USERID;
SELECT * FROM ORDER1, MEMBER1 WHERE ORDER1.ORDID(+)=MEMBER1.USERID;

-- full outer join
-- ansi sql만 가능함
SELECT * FROM ORDER1 FULL OUTER JOIN MEMBER1 ON ORDER1.ORDID=MEMBER1.USERID;

SELECT ITEM1.ITEMNAME, ITEM1.ITEMPRICE, ORDER1.*
    FROM
        ITEM1, ORDER1
    WHERE
        ITEM1.ITEMNO=ORDER1.ORDITEM AND ITEM1.ITEMPRICE >=4000;

--ansi sql        
SELECT ITEM1.ITEMNAME, ITEM1.ITEMPRICE, ORDER1.*
    FROM
        ITEM1 INNER JOIN ORDER1
    ON
        ITEM1.ITEMNO=ORDER1.ORDITEM
    WHERE
        ITEM1.ITEMPRICE >=4000;

SELECT * FROM DEPARTMENT;
SELECT * FROM EMPLOYEE;

INSERT INTO DEPARTMENT(NO, NAME, AREA) VALUES(101, '영업부', '');
INSERT INTO DEPARTMENT(NO, NAME, AREA) VALUES(102, '총무부', '');
INSERT INTO DEPARTMENT(NO, NAME, AREA) VALUES(103, '기획부', '');
INSERT INTO DEPARTMENT(NO, NAME, AREA) VALUES(104, '홍보부', '');
COMMIT;
ROLLBACK;

CREATE SEQUENCE SEQ_EMP_NO START WITH 1001 INCREMENT BY 1 NOMAXVALUE NOCACHE;

INSERT INTO EMPLOYEE(NO, NAME, DEPTNO, PEMPNO, POSITION, PAY, REGDATE) VALUES(SEQ_EMP_NO.NEXTVAL, '배고파', 104, 1001, '대리', 200000, CURRENT_DATE);

-- 부서테이블의 영업부는 지역을 대전으로, 총무부는 서울, 나머지는 부산으로 설정
UPDATE DEPARTMENT SET AREA =
    CASE
        WHEN (NO = 101) THEN '대전'
        WHEN (NO = 102) THEN '서울'
        ELSE '부산'
    END;
-- 사원 테이블에서 번호, 이름, 직급을 번호 순으로 내림차순 하여 조회
SELECT NO, NAME, POSITION FROM EMPLOYEE ORDER BY NO DESC;   
-- 사원테이블에서 급여가 0~200이면 세금이 5%, 201~300 10%, 나머지는 15%로 표시
SELECT NO 번호, NAME 이름, PAY 페이, 
    CASE
        WHEN (PAY >=0 AND PAY <=200) THEN PAY*0.05
        WHEN (PAY >=201 AND PAY <=300) THEN PAY*0.1
        ELSE PAY*0.15
    END 세금
FROM EMPLOYEE;  

-- (번호, 이름, 급여, 세금)
-- 사원테이블에서 영업부와 총무부만 조회, 이름으로 오름차순 조회
SELECT * FROM EMPLOYEE WHERE DEPTNO IN( 101, 102) ORDER BY NAME ASC;
-- 사원테이블과 부서 테이블을 inner join 하여 조회
SELECT EMPLOYEE.NO 번호,EMPLOYEE.NAME 이름, EMPLOYEE.PAY 급여, DEPARTMENT.NAME 부서, DEPARTMENT.AREA 지역 FROM DEPARTMENT, EMPLOYEE WHERE EMPLOYEE.DEPTNO=DEPARTMENT.NO;
-- (번호, 이름, 급여, 부서명, 지역)
-- 내장함수 (CURRENT_DATE, TO_CHAR)

SELECT
    NO 번호, NAME 이름, 
    PAY 급여, TO_CHAR(PAY, '999,999,999') 급여1,
    REGDATE 날짜, 
    TO_CHAR(REGDATE, 'YYYY"년"MM-DD HH24:MI:SS')날짜1    
FROM EMPLOYEE;

SELECT * FROM DEPARTMENT;
SELECT * FROM EMPLOYEE;

SELECT * FROM SUBJECT1;

SELECT * FROM PROFESSOR1;

SELECT * FROM STUDENT1;

CREATE SEQUENCE SEQ_STD_CODE
 START WITH 1 INCREMENT BY 1 NOMAXVALUE;

CREATE SEQUENCE SEQ_PRO_CODE
 START WITH 101 INCREMENT BY 1 NOMAXVALUE;
 
 CREATE SEQUENCE SEQ_CLS_CODE
 START WITH 1001 INCREMENT BY 1 NOMAXVALUE;
 
 SELECT * FROM CLASSROOM1;
 INSERT INTO CLASSROOM1(CLSNO, CLSADDR) VALUES('강의동2', '몰라1'); 
 SELECT * FROM COURSE1;
 INSERT INTO COURSE1(CURNO, STDNO, SUBCODE) VALUES(10003, 3, 1004);

-- 학생 5명 추가
INSERT INTO STUDENT1(STDNO, STDNAME, STDPHONE) VALUES (SEQ_STD_CODE.NEXTVAL, '김민영', 11111111111);
INSERT INTO STUDENT1(STDNO, STDNAME, STDPHONE) VALUES (SEQ_STD_CODE.NEXTVAL, '가가가', 22222222222);
INSERT INTO STUDENT1(STDNO, STDNAME, STDPHONE) VALUES (SEQ_STD_CODE.NEXTVAL, '나나나', 33333333333);
INSERT INTO STUDENT1(STDNO, STDNAME, STDPHONE) VALUES (SEQ_STD_CODE.NEXTVAL, '다다다', 44444444444);
INSERT INTO STUDENT1(STDNO, STDNAME, STDPHONE) VALUES (SEQ_STD_CODE.NEXTVAL, '마마마', 55555555555);

-- 교수 3명 등록
INSERT INTO PROFESSOR1(PRONO, PRONAME, PROPHONE) VALUES(SEQ_PRO_CODE.NEXTVAL, 'AAA', 9999999999);
INSERT INTO PROFESSOR1(PRONO, PRONAME, PROPHONE) VALUES(SEQ_PRO_CODE.NEXTVAL, 'BBB', 9999999999);
INSERT INTO PROFESSOR1(PRONO, PRONAME, PROPHONE) VALUES(SEQ_PRO_CODE.NEXTVAL, 'BBB', 9999999999);

-- 교과목 3개 개설
INSERT INTO SUBJECT1(SUBCODE, SUBNAME, PRONO, CLSNO) VALUES(SEQ_CLS_CODE.NEXTVAL, '바보들', 101, '강의동');
INSERT INTO SUBJECT1(SUBCODE, SUBNAME, PRONO, CLSNO) VALUES(SEQ_CLS_CODE.NEXTVAL, '천재들', 102, '강의동2');
INSERT INTO SUBJECT1(SUBCODE, SUBNAME, PRONO, CLSNO) VALUES(SEQ_CLS_CODE.NEXTVAL, '거지들', 101, '강의동2');

SELECT * FROM CLASSROOM1;

-- 전체 학생목록 (검색어가 포함, 페이지네이션)
SELECT STUDENT1.STDNO 학번, STUDENT1.STDNAME 이름, STUDENT1.STDPHONE 연락처 FROM STUDENT1 WHERE STDNO BETWEEN 1 AND 3;
SELECT * FROM(
SELECT STUDENT1.*, ROW_NUMBER() OVER (ORDER BY STDNO DESC) ROWN FROM STUDENT1 WHERE STDNAME LIKE '%'||''||'%')
WHERE ROWN BETWEEN 1 AND 3;

-- 학생테이블에 컬럼 추가
-- STDCLS : VARCHAR2(1) 반코드('A', 'B', 'C')
-- SCOREKOR : NUMBER(3)
-- SCOREENG : NUMBER(3)
-- SCOREMATH : NUMBER(3)
-- REGDATE : DATE
ALTER TABLE STUDENT1 ADD STDCLS VARCHAR2(1) DEFAULT 'A';
ALTER TABLE STUDENT1 ADD SCOREKOR NUMBER(3) DEFAULT 80;
ALTER TABLE STUDENT1 ADD SCOREENG NUMBER(3) DEFAULT 90;
ALTER TABLE STUDENT1 ADD SCOREMATH NUMBER(3) DEFAULT 70;
ALTER TABLE STUDENT1 ADD REGDATE DATE DEFAULT CURRENT_DATE;



INSERT INTO STUDENT1(STDNO, STDNAME, STDPHONE, STDCLS, SCOREKOR, SCOREENG, SCOREMATH, REGDATE) VALUES(SEQ_STD_CODE.NEXTVAL, '카카카', 23423432, 'B', 60, 70, 30, CURRENT_DATE);
INSERT INTO STUDENT1(STDNO, STDNAME, STDPHONE, STDCLS, SCOREKOR, SCOREENG, SCOREMATH, REGDATE) VALUES(SEQ_STD_CODE.NEXTVAL, '차차차', 23423432, 'C', 40, 60, 80, CURRENT_DATE);
COMMIT;

SELECT * FROM STUDENT1;

-- 그룹, 반별 학생 수(COUNT(*))
SELECT STDCLS, COUNT(*) FROM STUDENT1 GROUP BY(STDCLS);

-- 반별, 합계 SUM(  )
SELECT STDCLS 반, SUM(SCOREKOR) 합계 FROM STUDENT1 GROUP BY(STDCLS);

-- 반별, 평균( AVG ), 반올림 (ROUND(숫자, 자리수))
SELECT 
    STDCLS 반, 
    ROUND (AVG(SCOREKOR), 1) 국어평균,
    ROUND (AVG(SCOREENG), 1) 영어평균,
    ROUND (AVG(SCOREMATH), 1) 수학평균
FROM STUDENT1 
GROUP BY(STDCLS);

-- 1. 수학점수가 50점 이상인 학생들의 반별 평균점수 구하기
SELECT STDCLS, ROUND (AVG(SCOREMATH), 1) 수학평균  
    FROM STUDENT1 WHERE SCOREMATH >= 50 GROUP BY(STDCLS);
   
-- 2. 반별 평균 수학점수가 50점 이상인것
-- HAVING 결과에서 다시 필터
SELECT STDCLS, ROUND (AVG(SCOREMATH), 1) 수학평균  
FROM STUDENT1 GROUP BY(STDCLS) HAVING ROUND (AVG(SCOREMATH), 1)>= 50;

-- 3. 분별 합계
SELECT 
    TO_CHAR(REGDATE, 'YYYY-MM-DD HH24:MI')시간, 
    COUNT(*) 개수 
FROM STUDENT1 
GROUP BY(TO_CHAR(REGDATE, 'YYYY-MM-DD HH24:MI'));

SELECT * FROM ORDER1;
SELECT * FROM ITEM1;
SELECT * FROM MEMBER1;

-- INNER JOIN (A + B + C)

SELECT ORDITEM FROM(
    SELECT 
        ITEMORDER1.*, MEMBER1.USERNAME, MEMBER1.USERADDR 
    FROM MEMBER1, (
        SELECT 
            ITEM1.ITEMNAME, ITEM1.ITEMPRICE, ORDER1.*
        FROM 
            ITEM1, ORDER1 
        WHERE 
            ITEM1.ITEMNO=ORDER1.ORDITEM) ITEMORDER1
    WHERE MEMBER1.USERID=ITEMORDER1.ORDID) ORDER1VIEW
GROUP BY (ORDITEM);


-- 물품별 주문수량 합계
SELECT * FROM ORDER1 , ITEM1  WHERE ORDER1.ORDITEM=ITEM1.ITEMNO;

SELECT ITEM1.ITEMNAME 아이템이름,  SUM(ORDER1.ORDCNT) 주문수량합계 FROM ORDER1, ITEM1 WHERE ORDER1.ORDITEM=ITEM1.ITEMNO GROUP BY (ITEM1.ITEMNAME);

-- 물품별 재고수량 합계
SELECT * FROM ORDER1 , ITEM1  WHERE ORDER1.ORDITEM=ITEM1.ITEMNO;
SELECT * FROM ITEM1;
SELECT ITEM1.ITEMNAME , SUM(ITEM1.ITEMQTY) 합계 FROM ITEM1 GROUP BY(ITEM1.ITEMNAME);
SELECT * FROM ORDER1;
SELECT ITEM1.ITEMNAME 아이템이름, SUM(ITEM1.ITEMQTY) 재고수량합계 FROM ORDER1, ITEM1 WHERE ORDER1.ORDITEM=ITEM1.ITEMNO GROUP BY(ITEM1.ITEMNAME);

-- 재고수량 100개 미만인 물품개수
SELECT COUNT(*) FROM ITEM1 WHERE ITEMQTY < 100;

-- 시간대별 주문수량 합계
SELECT TO_CHAR(ORDDATE, 'YYYY-MM-DD HH24' ) 시간, SUM(ORDCNT) 주문수량 FROM ORDER1 GROUP BY( TO_CHAR(ORDDATE, 'YYYY-MM-DD HH24' )) ;

-- 고객별 주문수량, 주문금액 합계
SELECT * FROM ORDER1 , ITEM1  WHERE ORDER1.ORDITEM=ITEM1.ITEMNO;

SELECT ORDER1.ORDID, COUNT(*), SUM(ITEMPRICE*ORDCNT) FROM ORDER1 , ITEM1  WHERE ORDER1.ORDITEM=ITEM1.ITEMNO GROUP BY(ORDER1.ORDID);

SELECT * FROM MEMBER1, (
    SELECT ORDER1.ORDID, COUNT(*), SUM(ITEMPRICE*ORDCNT) 
    FROM ORDER1 , ITEM1  WHERE ORDER1.ORDITEM=ITEM1.ITEMNO 
    GROUP BY(ORDER1.ORDID)) T1 
WHERE MEMBER1.USERID = T1.ORDID;

-- 주문수량이 30개인 주문내역의 개수
SELECT * FROM ORDER1 , ITEM1  WHERE ORDER1.ORDITEM=ITEM1.ITEMNO AND ORDER1.ORDCNT<30;
SELECT COUNT(*) FROM ORDER1 , ITEM1  WHERE ORDER1.ORDITEM=ITEM1.ITEMNO AND ORDER1.ORDCNT<30;

-- 지역별 주문수량 합계
SELECT * FROM ORDER1 , MEMBER1  WHERE ORDER1.ORDID=MEMBER1.USERID;
SELECT MEMBER1.USERADDR 지역, SUM(ORDER1.ORDCNT) 주문수량합계 FROM ORDER1 , MEMBER1  WHERE ORDER1.ORDID=MEMBER1.USERID GROUP BY(MEMBER1.USERADDR);

-- FROM에서 MEMBER1 뒤에 명칭을 입력해주면 그걸로 인식 EX)FROM MEMBER1 M = M 이후부턴 MEMBER1을 M으로 써야함

-- 교수코드가 일치하는 교과목 조회 <= 교수페이지 (교과목 코드, 교과목명, 학생이름)


-- 학번이 일치하는 교과목 조회 <= 학생페이지 (교과목 코드, 교과목명, 교수명)

-- 강의실 코드별 교과목 조회 <= 강의실페이지 (교과목 코드, 교과목명, 강의실)
==========================================================================================================

-- 전체순위
SELECT MEMBER3.*, RANK() OVER (ORDER BY AGE DESC ) RK FROM MEMBER3;

-- 지역별 순위
SELECT MEMBER3.*, RANK() OVER (PARTITION BY GENDER ORDER BY AGE DESC ) RK FROM MEMBER3;


-- MEMBER3 에서 가장 나이가 많은 사람의 아이디를 구하는 함수 (FUNC_MEMBER3_AGE)
CREATE OR REPLACE FUNCTION FUNC_MEMBER3_AGE RETURN MEMBER3.ID%TYPE
IS
    V_AGE MEMBER3.ID%TYPE;
BEGIN
    SELECT ID INTO V_AGE FROM (
        SELECT MEMBER3.*,  ROW_NUMBER() OVER(ORDER BY MEMBER3.AGE DESC) ROWN FROM MEMBER3 
    )
    WHERE ROWN = 1;
    RETURN V_AGE;
END;
/

-- MEMBER3 에서 나이가 10~20인 사람의 수 (FUNC_MEMBER3_CNT)
CREATE OR REPLACE FUNCTION FUNC_MEMBER3_CNT RETURN NUMBER
IS
    V_AGE NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO V_AGE FROM MEMBER3 WHERE AGE BETWEEN 10 AND 20; 
    RETURN V_AGE;
END;
/
SELECT FUNC_MEMBER3_CNT FROM DUAL;

-- MEMBER3 아이디가 일치하는 사람의 성별을 남,여로 반환하는 함수(FUNC_MEMBER3_GENDER)
CREATE OR REPLACE FUNCTION FUNC_MEMBER3_GENDER( tmp VARCHAR2) RETURN VARCHAR2
IS
    V_GEND VARCHAR2(2);
BEGIN
    SELECT GENDER INTO V_GEND FROM MEMBER3 WHERE ID = tmp;
    IF V_GEND = 'F' THEN
        RETURN '여';
    ELSE
        RETURN '남';
    END IF;    
END;
/

SELECT FUNC_MEMBER3_GENDER('A') FROM DUAL;
SELECT MEMBER3.*, FUNC_MEMBER3_GENDER(ID) FROM MEMBER3;

-- BOARD3 에서 조회수가 10이상인 개수를 구하는 함수(FUNC_BOARD3_HIT)
CREATE OR REPLACE FUNCTION FUNC_BOARD3_HIT RETURN NUMBER
IS
    V_HIT NUMBER := 0;
BEGIN
    SELECT COUNT(*) INTO V_HIT FROM BOARD3 WHERE HIT >= 10;
    RETURN V_HIT;
END;
/
SELECT FUNC_BOARD3_HIT FROM DUAL;

-- 글번호가 전송되면 게시판의 자리수를 10자로 변환 (FUNC_BOARD3_HIT10)
-- 1이면 0000000001, 1235면 0000001235  
-- 참고 : SELECT B.*, LPAD(HIT,10, 0)  FROM BOARD3 B;
CREATE OR REPLACE FUNCTION FUNC_BAORD3_HIT10(tmp NUMBER) RETURN VARCHAR2
IS
    V_TMP VARCHAR2(10);
BEGIN
    SELECT LPAD(HIT,10, 0) INTO V_TMP FROM BOARD3 WHERE NO=tmp;
    RETURN V_TMP;
END;
/

SELECT B.*, FUNC_BAORD3_HIT10(B.NO)  FROM BOARD3 B;








SELECT * FROM BOARD3;
COMMIT;
--FUNC_BOARD3_SEQ
CREATE OR REPLACE FUNCTION FUNC_BOARD3_SEQ RETURN NUMBER
IS
    V_SEQ NUMBER := 0;
BEGIN
    -- 시퀀스의 다음 숫자 가져오기
    SELECT SEQ_BOARD3_NO.NEXTVAL INTO V_SEQ FROM DUAL;
    RETURN V_SEQ;
END;
/

-- 실행확인
SELECT FUNC_BOARD3_SEQ FROM DUAL;


INSERT ALL 
    INTO BOARD3(NO, TITLE, CONTENT, WRITER, HIT, REGDATE) 
    VALUES(FUNC_BOARD3_SEQ, 'A1', 'A', 'A', 1, CURRENT_DATE)
    INTO BOARD3(NO, TITLE, CONTENT, WRITER, HIT, REGDATE) 
    VALUES(FUNC_BOARD3_SEQ, 'A1', 'A', 'A', 1, CURRENT_DATE)
    INTO BOARD3(NO, TITLE, CONTENT, WRITER, HIT, REGDATE) 
    VALUES(FUNC_BOARD3_SEQ, 'A1', 'A', 'A', 1, CURRENT_DATE)
SELECT * FROM DUAL;
COMMIT;

SELECT * FROM BOARD3;

-- 함수 : FUNC_SUM(10)
CREATE OR REPLACE FUNCTION FUNC_SUM(tnum NUMBER) RETURN NUMBER
IS
    V_SUM NUMBER := 0;
BEGIN
    FOR I IN 1..tnum LOOP
        V_SUM := V_SUM + I;
    END LOOP;
    RETURN V_SUM; -- 프로시저와 다른점!!
END;
/

-- 실행결과 55
SELECT FUNC_SUM(10) FROM DUAL;
SELECT M.*, FUNC_SUM(USERAGE) FROM MEMBER1 M;


-- 함수 : FUNC_TODAY
CREATE OR REPLACE FUNCTION FUNC_TODAY RETURN VARCHAR2
IS
    V_DATE VARCHAR2(40);
BEGIN
    SELECT TO_CHAR(CURRENT_DATE, 'YYYY-MM-DD"년" HH24:MI:SS') 
    INTO V_DATE FROM DUAL;
    RETURN V_DATE; -- 프로시저와 다른점!!
END;
/

-- 함수확인
SELECT FUNC_TODAY FROM DUAL;


-- 함수 반환값 존재
SELECT CURRENT_DATE FROM DUAL;

-- 반올림
SELECT ROUND(1.2345,2) FROM DUAL;

-- 대문자로 변경
SELECT UPPER('aasdf')FROM DUAL;

SELECT M.*, UPPER(M.USERID)FROM MEMBER1 M;
-- 일부만 가져오기(나이, 시작위치, 개수)
SELECT M.*, SUBSTR(M.USERAGE, 0, 1)FROM MEMBER1 M;



-- BOARD3 테이블
-- 값을 전달했을때 추가되는 PROC_BRD_INSERT(0,1)
CREATE OR REPLACE PROCEDURE PROC_BRD_INSERT(
    V_TITLE IN BOARD3.TITLE%TYPE,
    V_CONTENT IN BOARD3.CONTENT%TYPE,
    V_WRITER IN BOARD3.WRITER%TYPE,
    V_CHK OUT NUMBER
)
IS
BEGIN
    INSERT INTO BOARD3(NO, TITLE, CONTENT, WRITER, HIT, REGDATE)
    VALUES(SEQ_BOARD3_NO.NEXTVAL, V_TITLE, V_CONTENT, V_WRITER, 1, CURRENT_DATE);
    COMMIT;
    V_CHK := 1;

EXCEPTION
    WHEN OTHERS THEN
    ROLLBACK;
    V_CHK := 0;

END;
/
DECLARE
    V_TITLE BOARD3.TITLE%TYPE := 'a';
    V_CONTENT BOARD3.CONTENT%TYPE := 'b';
    V_WRITER BOARD3.WRITER%TYPE := 'c';
    T_CHK NUMBER := 0;
    
BEGIN
    -- 프로시저 호출(IN변수, OUT변수)
    PROC_BRD_INSERT(V_TITLE, V_CONTENT, V_WRITER,  T_CHK);
    DBMS_OUTPUT.PUT_LINE('결과출력' || T_CHK);
END;
/
SELECT * FROM BOARD3;



-- 글번호가 없으면 추가, 있으면 조회수를 1 증가 PROC_BRD_UPSERT(0,1)
CREATE OR REPLACE PROCEDURE PROC_BRD_UPSERT(
    V_NO IN BOARD3.NO%TYPE,
    V_TITLE IN BOARD3.TITLE%TYPE,
    V_CONTENT IN BOARD3.CONTENT%TYPE,
    V_WRITER IN BOARD3.WRITER%TYPE,
    V_HIT IN BOARD3.HIT%TYPE
)
IS
    V_CHK NUMBER(2) := 0;
BEGIN
    SELECT COUNT(*) INTO V_CHK FROM BOARD3 WHERE NO=V_NO;
    
    IF V_CHK <= 0 THEN 
    
        INSERT INTO BOARD3(NO, TITLE, CONTENT, WRITER, HIT, REGDATE)
        VALUES(V_NO, V_TITLE, V_CONTENT,V_WRITER, V_HIT, CURRENT_DATE);
    ELSE
        UPDATE BOARD3 SET HIT= HIT+1 WHERE V_NO=NO;
    END IF;  
    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
    ROLLBACK;
END;
/
EXEC PROC_BRD_UPSERT(11, 'A', 'A', 'A', 1);
SELECT * FROM BOARD3;

-- 작성자가 일치하는 항목을 삭제하는 PROC_BRD_DELETE(0,1)
CREATE OR REPLACE PROCEDURE PROC_BRD_DELETE(
    V_WRITER IN BOARD3.WRITER%TYPE,
    V_CHK OUT NUMBER
)
IS
BEGIN
    DELETE FROM BOARD3 WHERE V_WRITER=WRITER;
    COMMIT;
    V_CHK := 1;
END;
/

DECLARE
    T_WRITER BOARD3.WRITER%TYPE := 'A';
    T_CHK NUMBER := 0;
BEGIN
    -- 프로시저 호출(IN변수, OUT변수)
    PROC_BRD_DELETE(T_WRITER, T_CHK);
    DBMS_OUTPUT.PUT_LINE('결과출력' || T_CHK);
END;
/
SELECT * FROM BOARD3;

-- 조건에 해당하는 항목의 개수를 반환하는 RPOC_BRD_SELECT(N개)
CREATE OR REPLACE PROCEDURE PROC_BRD_SELECT(
    V_HIT BOARD3.HIT%TYPE,
    V_CHK OUT NUMBER
)
IS
BEGIN
    SELECT COUNT(*) INTO V_CHK FROM  BOARD3 WHERE HIT >= V_HIT;
EXCEPTION
    WHEN OTHERS THEN
    V_CHK := 0;
END;
/
-- 실행 테스트
DECLARE
    T_CHK NUMBER := 0;
BEGIN
    -- 프로시저 호출(IN변수, OUT변수)
    PROC_BRD_SELECT(1,  T_CHK);
    DBMS_OUTPUT.PUT_LINE('결과출력' || T_CHK);
END;
/


DECLARE
    V_TITLE BOARD3.TITLE%TYPE := 'a';
    V_CONTENT BOARD3.CONTENT%TYPE := 'b';
    V_WRITER BOARD3.WRITER%TYPE := 'c';
    T_CHK NUMBER := 0;
    
BEGIN
    -- 프로시저 호출(IN변수, OUT변수)
    PROC_BRD_INSERT(V_TITLE, V_CONTENT, V_WRITER,  T_CHK);
    DBMS_OUTPUT.PUT_LINE('결과출력' || T_CHK);
END;
/


-- 프로시저명 PROC_DELETE_EXAM
CREATE OR REPLACE PROCEDURE PROC_DELETE_EXAM(
    V_ID IN MEMBER2.USERID%TYPE,
    V_CHK OUT NUMBER
)
IS
BEGIN
    -- DELETE FROM 테이블명 WHERE 조건
    DELETE FROM MEMBER2 WHERE USERID=V_ID;
    COMMIT;
    V_CHK := 1;
EXCEPTION
    WHEN OTHERS THEN
    ROLLBACK;
    V_CHK := 0;
    
END;
/
--실행 테스트
DECLARE
    T_ID MEMBER2.USERID%TYPE := 'a1';
    T_CHK NUMBER := 0;
BEGIN
    -- 프로시저 호출(IN변수, OUT변수)
    PROC_DELETE_EXAM(T_ID, T_CHK);
    DBMS_OUTPUT.PUT_LINE('결과출력' || T_CHK);
END;
/

SELECT * FROM MEMBER2;

-- 프로시저명 PROC_UPSERT_EXAM
-- 회원이 있으면 나이를 100으로 바꾸고 없으면 추가
CREATE OR REPLACE PROCEDURE PROC_UPSERT_EXAM(
    V_ID IN MEMBER2.USERID%TYPE,
    V_PW IN MEMBER2.USERPW%TYPE,
    V_NAME IN MEMBER2.USERNAME%TYPE,
    V_AGE IN MEMBER2.USERAGE%TYPE
)
IS
    -- 존재하는 하지 않는지 보관하는 변수(0,1이 저장됨.)
    V_CHK NUMBER(2) := 0;
BEGIN
    -- id가 존재하는 개수를 구함.
    SELECT COUNT(*) INTO V_CHK FROM MEMBER2 WHERE USERID=V_ID;
    
    IF V_CHK <= 0 THEN 
        -- INSERT
    INSERT INTO MEMBER2(USERID, USERPW, USERNAME, USERAGE, USERDATE)
    VALUES(V_ID, V_PW, V_NAME, V_AGE, CURRENT_DATE);
    ELSE
        -- UPDATE
    UPDATE MEMBER2 SET USERAGE=100 WHERE USERID=V_ID;    
    END IF;
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('UPSET 성공');
EXCEPTION
    WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('UPSET 실패');
END;
/
EXEC PROC_UPSERT_EXAM('D','C','가',11);
SELECT * FROM MEMBER2;
COMMIT;

-- 프로시저명 PROC_INSERT_EXAM
CREATE OR REPLACE PROCEDURE PROC_INSERT_EXAM(
    V_ID IN MEMBER2.USERID%TYPE,
    V_PW IN MEMBER2.USERPW%TYPE,
    V_NAME IN MEMBER2.USERNAME%TYPE,
    V_AGE IN MEMBER2.USERAGE%TYPE
)
IS
BEGIN
    -- 수행
    INSERT INTO MEMBER2( USERID, USERPW, USERNAME, USERAGE, USERDATE ) 
    VALUES(V_ID, V_PW, V_NAME, V_AGE, CURRENT_DATE);
    COMMIT;
    DBMS_OUTPUT.PUT_LINE('INSERT 성공');
EXCEPTION
    WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('INSERT 실패');
END;
/
-- 프로시저 실행
EXEC PROC_INSERT_EXAM('B','B','나',23);
-- 확인

COMMIT;

-- 입력한 점수를 기반으로 등급을 출력
CREATE OR REPLACE PROCEDURE PROC_IF_EXAM(
   -- "파라미터명" IN "타입"
   V_SCORE IN NUMBER -- 외부에서 숫자하나가 전달되어야 함.
)
IS
    -- 변수정의
    -- "변수명" "변수타입"
    V_GRADE VARCHAR2(2);
BEGIN
    -- 수행
    -- "프로시저 내용"
    IF(V_SCORE >= 90) THEN
        V_GRADE := 'A';
    ELSIF (V_SCORE >= 80) THEN
        V_GRADE := 'B';
    ELSE
        V_GRADE := 'F';
    END IF;
    DBMS_OUTPUT.PUT_LINE(V_GRADE);
END;
/
-- 실행하기
EXEC PROC_IF_EXAM(80);

-- 프로시저 숫자를 전달하면 구구단이 출력되는
-- 프로시저명 PROC_FOR_EXAM

CREATE OR REPLACE PROCEDURE PROC_FOR_EXAM(
    V_NUM IN NUMBER
)
IS
BEGIN
    FOR I IN 1..9 LOOP
    DBMS_OUTPUT.PUT_LINE(V_NUM || '*' || I || '=' || V_NUM*I);
    END LOOP;
END;
/
EXEC PROC_FOR_EXAM(1);


-- 여러개
DECLARE
    -- 변수정의
    CURSOR CUR IS (SELECT * FROM MEMBER2);
BEGIN
    -- CUR만큼 반복
    FOR TMP IN CUR() LOOP
        DBMS_OUTPUT.PUT_LINE('USERID : ' || TMP.USERID);
    END LOOP;
END;
/


-- 조회하기
DECLARE
    --  변수정의
    V_MEM MEMBER2%ROWTYPE;
    V_USERID MEMBER2.USERID%TYPE; -- VARCHAR2(30) %TYPE <= 타입을 그대로 넣어라
BEGIN
    -- SELECT * FROM 테이블명 WHERE 조건;
    SELECT * INTO V_MEM FROM MEMBER2 WHERE USERID='a';
    DBMS_OUTPUT.PUT_LINE( V_MEM.USERID);
    DBMS_OUTPUT.PUT_LINE( V_MEM.USERNAME);
END;
/


-- 추가하기( MEMBER2 테이블 )
DECLARE
    -- 변수정의
BEGIN
    -- 수행
    -- INSERT INTO 테이블명(컬럼명)VALUES(추가할값)
    FOR I IN 1..10 LOOP
        INSERT INTO MEMBER2(USERID, USERPW, USERNAME, USERAGE, USERDATE)
        VALUES('a'|| I, 'a', '가', 11, CURRENT_DATE);
    END LOOP;
    
    COMMIT;
EXCEPTION
    -- 오류처리
    WHEN OTHERS THEN
    ROLLBACK;
END;
/

SELECT * FROM MEMBER2;




-- 반복문 + 조건문
DECLARE
    V_NUM NUMBER(3) := 10; 
BEGIN
    FOR I IN 1..V_NUM LOOP
        IF MOD(I, 2) = 0 THEN
        DBMS_OUTPUT.PUT_LINE(I || '는 짝수');
        ELSE
        DBMS_OUTPUT.PUT_LINE(I || '는 홀수');
        END IF;
    END LOOP;    
END;
/


-- 반복문(구구단)
DECLARE
    V_NUM NUMBER := 3;
BEGIN
    -- for(int I=0;I<=9;I++)
    FOR i IN 1..9 LOOP
        DBMS_OUTPUT.PUT_LINE(V_NUM || '*' || I || '=' || V_NUM*I);
    END LOOP;

END;
/



-- 조건문
DECLARE
    V_SCORE NUMBER := 85;
    V_GRADE VARCHAR2(2) := '';
BEGIN
    IF(V_SCORE >= 90) THEN
        V_GRADE := 'A';
    ELSIF (V_SCORE >= 80) THEN
        V_GRADE := 'B';
    ELSIF (V_SCORE >= 70) THEN
        V_GRADE := 'C';
    ELSE
        V_GRADE := 'F';
    END IF;
    DBMS_OUTPUT.PUT_LINE('점수 : ' || V_SCORE ||'등급 : ' || V_GRADE);
END;
/

DECLARE
    -- int V_NUM = 1234;
    -- String V_STR = "";
    V_NUM NUMBER(4):= 1234;
    V_STR VARCHAR2(10);
BEGIN
    V_STR := 'hello';
    DBMS_OUTPUT.PUT_LINE('V_NUM : '  || V_NUM);
    DBMS_OUTPUT.PUT_LINE('V_STR : '  || V_STR);
END;
/

BEGIN
    DBMS_OUTPUT.PUT_LINE('hello');
END;
/  
--OUTPUT 환경을 ON으로
SET SERVEROUTPUT ON;